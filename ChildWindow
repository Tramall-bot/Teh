#define DIVISIONS 5
#define MoveTo(hdc, x, y) MoveToEx(hdc, x, y, NULL)
#include<Windows.h>
#include<tchar.h>

TCHAR szChildClass[] = _T("Checker_Child");

LRESULT CALLBACK ChildWndProc(HWND, UINT, WPARAM, LPARAM);
LRESULT CALLBACK WndProc(HWND, UINT, WPARAM, LPARAM);
int WINAPI WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nCmdShow) {
	HWND hWnd;
	TCHAR szClassName[] = _T("Cheker");
	WNDCLASSEX wc;
	MSG msg;
	wc.cbSize = sizeof(wc);
	wc.style = CS_HREDRAW | CS_VREDRAW;
	wc.lpfnWndProc = WndProc;
	wc.cbClsExtra = 0;
	wc.cbWndExtra = 0;
	wc.hInstance = hInstance;
	wc.hIcon = LoadIcon(NULL, IDI_APPLICATION);
	wc.hCursor = LoadCursor(NULL, IDC_ARROW);
	wc.hbrBackground = (HBRUSH)GetStockObject(WHITE_BRUSH);
	wc.lpszMenuName = NULL;
	wc.lpszClassName = szClassName;
	wc.hIconSm = LoadIcon(NULL, IDI_APPLICATION);
	RegisterClassEx(&wc);
	wc.lpfnWndProc = ChildWndProc;
	wc.cbWndExtra = sizeof(WORD);
	wc.hIcon = NULL;
	wc.hIconSm = NULL;
	wc.lpszClassName = szChildClass;
	RegisterClassEx(&wc);
	hWnd = CreateWindow(szClassName, _T("Checker"), WS_OVERLAPPEDWINDOW, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, CW_USEDEFAULT, NULL, NULL,
		hInstance, NULL);

	ShowWindow(hWnd, nCmdShow);
	UpdateWindow(hWnd);
	while (GetMessage(&msg, NULL, 0, 0)) {
		TranslateMessage(&msg);
		DispatchMessageW(&msg);
	}
	return msg.wParam;
}
LRESULT CALLBACK WndProc(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam) {
	HDC hdc;
	PAINTSTRUCT ps;
	static HWND hwndChild[DIVISIONS][DIVISIONS];
	int cx, cy, x, y;
	switch (uMsg) {
	case WM_CREATE:
		for (x = 0; x < DIVISIONS; x++)
		{
			for (y = 0; y < DIVISIONS; y++) {
				hwndChild[x][y] = CreateWindow(szChildClass, NULL, WS_CHILDWINDOW | WS_VISIBLE, 0, 0, 0, 0, hWnd, 
					(HMENU)(y << 8 | x), (HINSTANCE)GetWindowLong(hWnd, GWL_HINSTANCE), NULL);
			}
		}
		break;
	case WM_SIZE:
		cx = LOWORD(lParam) / DIVISIONS;
		cy = HIWORD(lParam) / DIVISIONS;
		for (x = 0; x < DIVISIONS; x++)
		{
			for (y = 0; y < DIVISIONS; y++) {
				MoveWindow(hwndChild[x][y], x * cx, y * cy, cx, cy, TRUE);
			}
		}
		break;
	case WM_LBUTTONDOWN:
		MessageBeep(0);
		break;
	case WM_DESTROY:
		PostQuitMessage(0);
		break;
	default:
		return DefWindowProc(hWnd, uMsg, wParam, lParam);
	}
	return 0;

}

LRESULT CALLBACK ChildWndProc(HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam)
{
	HDC hdc;
	PAINTSTRUCT ps;
	RECT rect;
	int temp;
	switch (msg)
	{
	case WM_CREATE:
		SetWindowWord(hWnd, 0, 0);
		break;
	case WM_LBUTTONDOWN:
		SetWindowWord(hWnd, 0, 1 ^ GetWindowWord(hWnd, 0));
		temp = GetWindowWord(hWnd, 0);
		InvalidateRect(hWnd, NULL, FALSE);
		break;
	case WM_PAINT:
		hdc = BeginPaint(hWnd, &ps);
		GetClientRect(hWnd, &rect);
		Rectangle(hdc, 0, 0, rect.right, rect.bottom);
		if (GetWindowWord(hWnd, 0))
		{
			MoveTo(hdc, 0, 0);
			LineTo(hdc, rect.right, rect.bottom);
			MoveTo(hdc, 0, rect.bottom);
			LineTo(hdc, rect.right, 0);
		}
		EndPaint(hWnd, &ps);
		break;
	default:
		return DefWindowProc(hWnd, msg, wParam, lParam);
	}
}
